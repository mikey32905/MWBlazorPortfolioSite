@using System.Text
@inject TerminalService TerminalSvc
@inject HttpClient Http
@inject IJSRuntime JS
@implements IDisposable

<div class="editor-wrapper">
    @if (string.IsNullOrEmpty(FileContent))
    {
        @* This prevents the "Invisible" state *@
        <div class="loading-overlay">
            <span class="glitch-text">FETCHING_SOURCE_DATA...</span>
        </div>
    }
    else
    {
        <pre><code id="highlight-target" class="language-@SelectedFile.Language">@FileContent</code></pre>
    }
</div>

<div class="editor-container">
    <div class="editor-tabs">
        <div class="tab active">
            <span class="file-icon">@SelectedFile.Icon</span>
            @SelectedFile.FileName@SelectedFile.Extension
            <span class="tab-close">×</span>
        </div>
    </div>

    <div class="code-viewport">
        <div class="line-numbers">
            @for (int i = 1; i <= LineCount; i++)
            {
                <div class="line-num">@i</div>
            }
        </div>
        <pre class="code-content"><code>@((MarkupString)HighlightedCode)</code></pre>
    </div>
</div>

@code {
    [Parameter] public ProjectFile SelectedFile { get; set; }

    // This is the "Safety Net" that prevents the VS 2026 crash
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? UnmatchedParameters { get; set; }

    // Add this one as an "Alias" to catch the Identity.cs call
    [Parameter] public ProjectFile Project { get; set; }
    private string? FileContent;

    private string HighlightedCode = "";
    private int LineCount = 1;

    protected override async Task OnParametersSetAsync()
    {
        // 1. Guard against nulls
        if (SelectedFile == null || string.IsNullOrEmpty(SelectedFile.PhysicalPath))
        {
            FileContent = "NO_FILE_SELECTED";
            return;
        }

        try
        {
            // 2. Clear old text so the user sees it's working
            FileContent = "LOADING_SOURCE...";
            StateHasChanged();

            // 3. Fetch the new file
            // Note: Adding a timestamp (?v=) helps bypass GitHub's cache during testing
            var versionedPath = $"{SelectedFile.PhysicalPath}?v={DateTime.Now.Ticks}";
            FileContent = await Http.GetStringAsync(versionedPath);

            StateHasChanged();

            // 4. Trigger the JS Highlighting
            // We wait a tiny bit to ensure the HTML has rendered the new text
            await Task.Delay(100);
            await JS.InvokeVoidAsync("applyHighlighting", "highlight-target");
        }
        catch (Exception ex)
        {
            FileContent = $"SYSTEM_ERROR: Could not load {SelectedFile.PhysicalPath}. Check GitHub case-sensitivity.";
            StateHasChanged();
        }
    }

     public void Dispose() { }
}
