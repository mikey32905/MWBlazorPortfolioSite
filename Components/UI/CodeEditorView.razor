@using System.Text
@inject TerminalService TerminalSvc
@inject HttpClient Http
@inject IJSRuntime JS
@implements IDisposable

<div class="editor-wrapper">
    @if (string.IsNullOrEmpty(FileContent))
    {
        @* This prevents the "Invisible" state *@
        <div class="loading-overlay">
            <span class="glitch-text">FETCHING_SOURCE_DATA...</span>
        </div>
    }
    else
    {
        <pre><code id="highlight-target" class="language-@SelectedFile.Language">@FileContent</code></pre>
    }
</div>

<div class="editor-container">
    <div class="editor-tabs">
        <div class="tab active">
            <span class="file-icon">@SelectedFile.Icon</span>
            @SelectedFile.FileName@SelectedFile.Extension
            <span class="tab-close">×</span>
        </div>
    </div>

    <div class="code-viewport">
        <div class="line-numbers">
            @for (int i = 1; i <= LineCount; i++)
            {
                <div class="line-num">@i</div>
            }
        </div>
        <pre class="code-content"><code>@((MarkupString)HighlightedCode)</code></pre>
    </div>
</div>

@code {
    [Parameter] public ProjectFile SelectedFile { get; set; }

    // This is the "Safety Net" that prevents the VS 2026 crash
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? UnmatchedParameters { get; set; }

    // Add this one as an "Alias" to catch the Identity.cs call
    [Parameter] public ProjectFile Project { get; set; }
    private string? FileContent;

    private string HighlightedCode = "";
    private int LineCount = 1;

    protected override async Task OnParametersSetAsync()
    {
        if (SelectedFile == null) return;

        try
        {
            // Clear old content so the user knows a switch is happening
            FileContent = "FETCHING_SOURCE_CODE...";
            StateHasChanged();

            // Fetch the new file
            FileContent = await Http.GetStringAsync(SelectedFile.PhysicalPath);

            // Let the UI render the text
            StateHasChanged();

            // Wait a tiny bit for the DOM to update, then highlight
            await Task.Delay(50);
            await JS.InvokeVoidAsync("applyHighlighting", "highlight-target");
        }
        catch (Exception ex)
        {
            FileContent = $"SYSTEM_ERROR: Could not load {SelectedFile.PhysicalPath}. Check GitHub case-sensitivity.";
        }
    }

    // private async Task LoadSourceCode()
    // {
    //     // Project.PhysicalPath would be "Developer/Identity.cs"
    //     try
    //     {
    //         // Use the PhysicalPath (e.g., Projects/App/File.razor.txt)
    //         FileContent = await Http.GetStringAsync(SelectedFile.PhysicalPath);
            
    //         // Allow the UI to render the code before calling JS
    //         StateHasChanged(); 
            
    //         // Short delay ensures the DOM is ready for the highlighter
    //         await Task.Delay(50); 
    //         await JS.InvokeVoidAsync("applyHighlighting", "highlight-target", SelectedFile.Language);
    //         // await StreamCodeToUI(FileContent);
    //     }
    //     catch (Exception ex)
    //     {
    //         FileContent = $"CRITICAL_ERROR: Unable to mount {SelectedFile.PhysicalPath}. Error: {ex.Message}";
    //         StateHasChanged();
    //     }
    // }

    // private async Task StreamCodeToUI(string content)
    // {
    //     // 1. Clear previous content
    //     HighlightedCode = ""; 
    //     StateHasChanged();

    //     // 2. Split the raw file into lines
    //     var lines = content.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
    //     LineCount = lines.Length;

    //     StringBuilder sb = new();

    //     // 3. Loop through and "Type" each line
    //     foreach (var line in lines)
    //     {
    //         // Highlight the line before appending
    //         string processedLine = ProcessHighlighting(line);
        
    //         sb.AppendLine(processedLine);
    //         HighlightedCode = sb.ToString();

    //         // 4. Trigger UI refresh and wait (speed of the stream)
    //         StateHasChanged();
    //         await Task.Delay(20); 
    //     }

    //     TerminalSvc.AddLog($"File rendering complete: {SelectedFile.FileName}", LogType.Success);
    // }

    // private string ProcessHighlighting(string line)
    // {
    //     if (string.IsNullOrWhiteSpace(line)) return line;

    //     // Simple keyword list for the "Source Code" feel
    //     string[] keywords = { "public", "private", "class", "async", "await", "string", "var", "new", "return", "if", "namespace", "using" };

    //     // Escape HTML characters to prevent rendering bugs
    //     line = line.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;");

    //     foreach (var word in keywords)
    //     {
    //         // Use a space or boundary check to ensure we don't highlight words inside other words
    //         line = line.Replace(word + " ", $"<span class='keyword'>{word}</span> ");
    //     }

    //     // Optional: Highlight comments
    //     if (line.Trim().StartsWith("//"))
    //     {
    //         return $"<span class='comment'>{line}</span>";
    //     }

    //     return line;
    // }
    
    // private string GetProjectCode(string fileName)
    // {
    //     // In a real app, you might load this from a .txt file in wwwroot
    //     // For now, return a placeholder or the Identity.cs string we wrote
    //     if (fileName == "Identity") return "// Identity.cs loaded...\npublic class ProfessionalProfile ...";
    //     return "// Loading module source code...";
    // }

    public void Dispose() { }
}
