@using System.Text
@inject TerminalService TerminalSvc
@inject HttpClient Http
@implements IDisposable

<div class="editor-container">
    <div class="editor-tabs">
        <div class="tab active">
            <span class="file-icon">@Project.Icon</span>
            @Project.FileName@Project.Extension
            <span class="tab-close">×</span>
        </div>
    </div>

    <div class="code-viewport">
        <div class="line-numbers">
            @for (int i = 1; i <= LineCount; i++)
            {
                <div class="line-num">@i</div>
            }
        </div>
        <pre class="code-content"><code>@((MarkupString)HighlightedCode)</code></pre>
    </div>
</div>

@code {
    [Parameter] public ProjectFile Project { get; set; } = new();

    private string HighlightedCode = "";
    private int LineCount = 1;

    protected override async Task OnParametersSetAsync()
    {
        // Reset and trigger the "Streaming" effect
        HighlightedCode = "";
        await LoadSourceCode();
    }

    private async Task LoadSourceCode()
    {
        // Project.PhysicalPath would be "Developer/Identity.cs"
        try
        {
            // The Http client uses the BaseAddress we set in Program.cs
            var content = await Http.GetStringAsync(Project.PhysicalPath);
            await StreamCodeToUI(content);
        }
        catch (Exception ex)
        {
            TerminalSvc.AddLog($"ERR: Could not resolve {Project.PhysicalPath}", LogType.Error);
        }
    }

    private async Task StreamCodeToUI(string content)
    {
        // 1. Clear previous content
        HighlightedCode = ""; 
        StateHasChanged();

        // 2. Split the raw file into lines
        var lines = content.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
        LineCount = lines.Length;

        StringBuilder sb = new();

        // 3. Loop through and "Type" each line
        foreach (var line in lines)
        {
            // Highlight the line before appending
            string processedLine = ProcessHighlighting(line);
        
            sb.AppendLine(processedLine);
            HighlightedCode = sb.ToString();

            // 4. Trigger UI refresh and wait (speed of the stream)
            StateHasChanged();
            await Task.Delay(20); 
        }

        TerminalSvc.AddLog($"File rendering complete: {Project.FileName}", LogType.Success);
    }

    private string ProcessHighlighting(string line)
    {
        if (string.IsNullOrWhiteSpace(line)) return line;

        // Simple keyword list for the "Source Code" feel
        string[] keywords = { "public", "private", "class", "async", "await", "string", "var", "new", "return", "if", "namespace", "using" };

        // Escape HTML characters to prevent rendering bugs
        line = line.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;");

        foreach (var word in keywords)
        {
            // Use a space or boundary check to ensure we don't highlight words inside other words
            line = line.Replace(word + " ", $"<span class='keyword'>{word}</span> ");
        }

        // Optional: Highlight comments
        if (line.Trim().StartsWith("//"))
        {
            return $"<span class='comment'>{line}</span>";
        }

        return line;
    }
    
    private string GetProjectCode(string fileName)
    {
        // In a real app, you might load this from a .txt file in wwwroot
        // For now, return a placeholder or the Identity.cs string we wrote
        if (fileName == "Identity") return "// Identity.cs loaded...\npublic class ProfessionalProfile ...";
        return "// Loading module source code...";
    }

    public void Dispose() { }
}
